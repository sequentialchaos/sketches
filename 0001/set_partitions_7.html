<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Set Partitions</title>
  <script src="../lib/scmath.js"></script>
  <script src="../lib/p5.min.js"></script>
  <script src="../lib/p5.dom.min.js"></script>
</head>

<body>
  <script type="text/javascript">
    let partitions;
    let side;
    let N;
    let hue;
    let interval;
    let currentIndex;
    let input1, input2, button;
    let timer;
    let paused;

    function setup() {
      let label1 = createElement("span", "Number of elements: ");
      input1 = createInput(5, "number").size(35, 15);
      input1.attribute("min", 2);
      input1.attribute("max", 11);

      let label2 = createElement("span", "  Wait interval (ms): ");
      input2 = createInput(500, "number").size(68, 15);
      input2.attribute("min", 1);
      input2.attribute("max", 120000);

      createElement("span", " ");
      button = createButton("Show partitions");
      createElement("span", " ");
      

      N = input1.value();

      interval = 500;

      createElement("br");
      createElement("br");
      side = 800;
      createCanvas(side, side);
      createElement("br");
      background(207);

      let button_toggle_pause;
      button.mousePressed(function () {
        clearInterval(timer);

        paused = false;
        if (button_toggle_pause == null)
          button_toggle_pause = createButton("Pause");
        button_toggle_pause.html("Pause");

        N = Number(input1.value());
        hue = 255 / N;
        interval = input2.value();
        console.log(N);
        partitions = getPartitions(N);

        // Get the first partition
        currentIndex = 0;
        let partition = partitions[currentIndex];

        // Draw first partition
        drawFrame(partition);

        // Draw each subsequent partition after the given interval
        timer = setInterval(function () {
          button_toggle_pause.mousePressed(function () {
            if (paused) {
              paused = false;
              button_toggle_pause.html("Pause");
            }
            else {
              paused = true;
              button_toggle_pause.html("Play");
            }
          })
          if (!paused) {
            if (currentIndex < partitions.length - 1)
              currentIndex++;
            else
              return;
          } 

          partition = partitions[currentIndex];
          drawFrame(partition)
        }, interval);
      });

    }

    function drawFrame(partition) {
      background(207);
      drawPartition(partition);
      drawVertices();
      drawCount();
      drawTitle();
      drawStringRepresentation(partition);
    }

    function drawLines(block, j) {
      if (block.length <= 1)
        return;

      let shape = beginShape();
      colorMode(HSB, 255);
      let c = color(255 - hue * (j + 1), 190, 210);
      shape.fill(c);
      for (let i = 0; i < block.length; i++) {
        let v1 = block[i],
          v2 = block[(i + 1) % block.length],
          c1 = coordinates(v1),
          c2 = coordinates(v2);

        strokeWeight(7);
        vertex(c1.x, c1.y);
        vertex(c2.x, c2.y);
      }
      endShape();
    }

    function drawPartition(partition) {
      let hue = 0;
      partition.forEach((block, i) => {
        drawLines(block, i);
      });
    }

    function drawVertices() {
      for (let i = 1; i < N + 1; i++) {
        let coords = coordinates(i, N, side, side);
        let radius = side / 10;

        // Vertex
        strokeWeight(7);
        fill(255);
        ellipse(coords.x, coords.y, radius, radius);

        // Label
        fill(5);
        textFont('Cambria')
        textStyle(BOLD);
        textAlign(CENTER, CENTER);
        textSize(radius / 2);
        text(i, coords.x, coords.y);
      }
    }

    function drawStringRepresentation(partition) {
      fill(0);
      textAlign(LEFT, BOTTOM);
      textSize(30);
      textStyle(BOLD);
      textFont('Calibri');
      text(setPartitionToString(partition), side * 0.015, side * 0.985);
    }

    function drawCount() {
      fill(0);
      textAlign(RIGHT, BOTTOM);
      textSize(30);
      textStyle(BOLD);
      textFont('Calibri');
      text((currentIndex + 1) + " / " + partitions.length, side * 0.985, side * 0.985);
    }

    function drawTitle() {
      fill(0);
      textAlign(LEFT, TOP);
      textSize(45);
      textStyle(BOLD);
      textFont('Calibri');
      text(N + "-element set partitions", side * 0.015, side * 0.015);
    }

    function getPartitions(N) {
      // Get all set partitions of {0, 1, ..., N-1}
      partitions = [];
      for (let partition of setPartitions(N))
        partitions.push(partition);
      return partitions;
    }

    function coordinates(index) {
      let angle = TWO_PI / N;
      let cx = side / 2,
        cy = side * 53 / 100;
      let radius = side * 32 / 100;
      let x = cx + cos(index * angle - TWO_PI / 4 - angle) * radius;
      let y = cy + sin(index * angle - TWO_PI / 4 - angle) * radius;
      return { x: x, y: y }
    }



    function arrayToSetString(array) {

    }

    function textPartition(partition) {

    }
  </script>
  </div>
</body>

</html>