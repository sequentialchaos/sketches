<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/p5.js"></script>
  <title>Rainbow Cube</title>
  <style type="text/css">
    html, body { 
      padding: 0; margin: 0; 
    }
  </style>
</head>
<body>
  <script type = "text/javascript">
    let width, height;
    let layers = [];
    
    function setup() {
      width = windowWidth;
      height = windowHeight;
      createCanvas(width, height, WEBGL);
      
      s = 3;
      r = width / s * 1.5;
      maxCubes = round(height / r);
    
      hue = 0;
      hueIncrement = 180 / (s*s*s);
      console.log(maxCubes);
      // camera(500, 500, 5000, 500, 0, 0, 0, 1, 0);
      // normalMaterial();
      camera(0, -height * 4, (height/2.0) / tan(PI*30.0 / 180.0), 0, -1500, 0, 0, 1, 0);
      xPivot = atan(cos(QUARTER_PI));
      yPivot = PI*0.75;
      zPivot = PI;
      //ortho(-1000, 1000, 1000, -1000, 0, 2000);
      rotateX(xPivot);//PI * 1.5);
      rotateY(yPivot);//PI * 1.3);
      rotateZ(zPivot);
      smooth();
      // setAttributes('antialias', true);
      background(0, 2, 5, 230);
      



      translate((r + 1) * (s - 1) * 0.75, 0, (r + 1) * (s - 1) * 0.75); //(r+1)*(s-1) / 6);
      
      
      signs = [-1, -1, 1, 1];
      directions = ['x', 'z'];
      
      instructions = [];
      for (let layer = 0; layer < s; layer++) {
        getLayer(layer);
        if (layer < s-1) {
          beginNextLayer();
        }
      }
      // console.log(instructions, instructions.length);
      // console.log(instructions[0]);
      
      colorMode(HSB, 255);
      strokeWeight(5);
      // box(r);
      let index = 0;
      let instruction = instructions[index];
      
      let interval = setInterval(function() {
        let instruction = instructions[index];
        let t = instruction.translation;
        let h = instruction.hue;
        fill(h, 130, 100);
        translate(t[0], t[1], t[2]);
        box(r);
        index++;
        if (index == instructions.length) {
          clearInterval(interval);
        }
      }, 300);
    }
    function getTimesToMove(layer, turns) {
      if (layer == 0) {
        if (turns == 0) {
          return s;
        }
        if (turns == 1 || turns == 2) {
          return s-1;
        }
        if (turns == 3 || turns == 4) {
          return s-2;
        }
      }
      if (layer % 2 == 0) {
        if (turns < 3) {
          return s-1;
        } else {
          return s-2;
        }
      }
    }
    function getLayer(layer) {
      if (layer % 2 == 0) {
        getEvenLayer(layer);
      } else {
        getOddLayer();
      }
    }
    
    function beginNextLayer() {
      instruction = {
        translation : [0, r + 1, 0],
        hue : hue % 255
      }
      instructions.push(instruction);
      hue += hueIncrement;
    }
    function startFirstLayer() {

    }
    function getEvenLayer(layer) {
      turns = 0;
      maxTurns = 2 * s - 2;
      index = 0;
      
      while (turns <= maxTurns) {
        sign = signs[index % 4];
        direction = directions[index % 2];
        timesToMove = getTimesToMove(layer, turns);
        let moves = 0;
        while (moves < timesToMove) {
          instruction = {};
          if (direction == 'x') {
            instruction.translation = [sign * (r + 1), 0, 0];
          } else {
            instruction.translation = [0, 0, sign * (r + 1)];
          }
          instruction.hue = hue % 255;
          instructions.push(instruction);
          hue += hueIncrement;
          moves++;
        }
        turns++;
        index++;
      }
    }
    
    function getOddLayer() {
      maxTurns = 2 * s - 1;
      turns = 0;
      index = 3;
      timesToMove = 1;
      while (turns < maxTurns) {
        sign = signs[index % 4];
        direction = directions[(index) % 2];
        let moves = 0;
        while (moves < timesToMove) {
          instruction = {};
          if (direction == 'x') {
            instruction.translation = [sign * (r + 1), 0, 0];
          } else {
            instruction.translation = [0, 0, sign * (r + 1)];
          }
          instruction.hue = hue % 255;
          instructions.push(instruction);
          hue += hueIncrement;
          moves++;
        }
        if ((turns < maxTurns - 3) && (turns % 2 == 1)) {
          console.log(turns);
          timesToMove++;
        }
    
        turns++;
        index++;
      }
    }
    
    // function draw() {
      // background(0, 10, 20, 230)
      // normalMaterial();
      // ortho(-300, 300, 300, -300, 0, 1000);
      // rotateX(xViewOffset);
      // rotateY(yViewOffset);
      // rotateX(PI * 0.8);
      // rotateY(PI * 0.8);
      // rotateZ(PI * .2);
      // box(r);
      // //translate((r + 1) * (s - 1) * 0.75, 0, 0); //(r+1)*(s-1) / 6);
      // if (frameCount % 100 == 0 && index < instructions.length) {
      // 	let i = instructions[index];
      //   console.log(i);
      //   let t = i.translation;
      //   let h = i.hue;
      //   colorMode(HSB, 255);
      //   fill(h, 120, 120);
      //   translate(t[0], t[1], t[2]);
      //   console.log(t[0], t[1], t[2]);
      //   console.log(index);
      //   index++;
      // }
      
      
    // }
    </script>
</body>
</html>
